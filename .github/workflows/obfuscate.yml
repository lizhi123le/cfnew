name: 混淆并创建 GitHub 发行版
on:
  push:
    branches:
      - main
  workflow_dispatch:
  schedule:
    - cron: '0 */9 * * *'

jobs:
  obfuscate-and-release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: write

    steps:
      - name: Check out repository
        uses: actions/checkout@v4
        with:
          persist-credentials: true

      # ==================== 检查上游更新 ====================
      - name: 检查上游仓库更新并同步备份文件（正确的三方合并）
        id: check-update
        run: |
          set -euo pipefail
          WORKER_URL="https://raw.githubusercontent.com/byJoey/cfnew/refs/heads/main/明文源吗"
          MD_URL="https://raw.githubusercontent.com/byJoey/cfnew/refs/heads/main/README.md"
          BACKUP_FILE="明文源吗"
          BASE_FILE="明文源吗.js.upstream"
          MD_FILE="README.md"
          WORKER_HASH_FILE=".明文源吗_hash"
          MD_HASH_FILE=".md_hash"

          curl -fsSL -o temp明文源吗 "$WORKER_URL"
          curl -fsSL -o temp_md.md "$MD_URL"

          NEW_WORKER_HASH=$(sha256sum temp明文源吗 | cut -d' ' -f1)
          NEW_MD_HASH=$(sha256sum temp_md.md | cut -d' ' -f1)
          OLD_WORKER_HASH=$(cat "$WORKER_HASH_FILE" 2>/dev/null || echo "")
          OLD_MD_HASH=$(cat "$MD_HASH_FILE" 2>/dev/null || echo "")

          HAS_UPDATE="false"

          # ========== 处理 明文源吗（真正的三方合并） ==========
          if [ "$NEW_WORKER_HASH" != "$OLD_WORKER_HASH" ]; then
            echo "上游 明文源吗 有更新"

            # 首次运行：初始化基线
            if [ ! -f "$BASE_FILE" ]; then
              echo "首次运行，初始化基线文件"
              cp temp明文源吗 "$BASE_FILE"
              # 如果没有备份文件，用上游作为备份
              if [ ! -f "$BACKUP_FILE" ]; then
                cp temp明文源吗 "$BACKUP_FILE"
              else
                echo "发现现有备份文件，保留用户修改"
              fi
            else
              echo "执行三方合并：backup(local) vs base vs upstream"
              
              # 准备三个文件进行合并
              # local: 当前的用户修改（backup文件）
              if [ -f "$BACKUP_FILE" ]; then
                cp "$BACKUP_FILE" local明文源吗.js
                echo "使用备份文件作为 local（用户修改）"
              else
                echo "警告：备份文件不存在，使用上游版本作为 local"
                cp "$BASE_FILE" local明文源吗.js
              fi
              
              # base: 上次的上游版本
              cp "$BASE_FILE" base明文源吗
              
              # upstream: 新的上游版本
              cp temp明文源吗 upstream明文源吗.js

              # 执行三方合并
              echo "开始三方合并..."
              if git merge-file local明文源吗.js base明文源吗 upstream明文源吗.js; then
                echo "三方合并成功"
                MERGE_SUCCESS="true"
              else
                echo "三方合并存在冲突，尝试自动解决..."
                MERGE_SUCCESS="false"
                
                # 检查冲突标记
                if grep -q "<<<<<<" local明文源吗.js; then
                  echo "发现合并冲突，创建冲突报告文件"
                  echo "# 合并冲突报告" > merge_conflict.md
                  echo "## 冲突时间: $(date)" >> merge_conflict.md
                  echo "## 上游更新哈希: $NEW_WORKER_HASH" >> merge_conflict.md
                  echo "" >> merge_conflict.md
                  echo "以下文件包含冲突标记，需要手动解决：" >> merge_conflict.md
                  echo "" >> merge_conflict.md
                  echo '```' >> merge_conflict.md
                  cat local明文源吗.js >> merge_conflict.md
                  echo '```' >> merge_conflict.md
                  
                  # 作为后备方案，使用上游版本但保留原备份供手动处理
                  echo "使用上游版本作为基础，保留原备份文件供后续手动合并"
                  cp temp明文源吗 local明文源吗.js
                  # 保存原备份为 .old 版本
                  cp "$BACKUP_FILE" "${BACKUP_FILE}.old"
                else
                  echo "合并成功（无冲突标记）"
                  MERGE_SUCCESS="true"
                fi
              fi

              # 更新基线文件为新的上游版本
              echo "更新基线文件为新的上游版本"
              mv -f temp明文源吗 "$BASE_FILE"
              
              # 保存合并结果作为备份
              echo "保存合并结果作为备份文件"
              mv -f local明文源吗.js "$BACKUP_FILE"
            fi

            echo "$NEW_WORKER_HASH" > "$WORKER_HASH_FILE"
            HAS_UPDATE="true"
          else
            echo "上游 明文源吗 无更新"
            rm -f temp明文源吗
          fi

          # ========== 处理 README.md（覆盖方式） ==========
          if [ ! -f "$MD_FILE" ] || [ "$NEW_MD_HASH" != "$OLD_MD_HASH" ]; then
            echo "README.md 需要更新或初次创建"
            mv -f temp_md.md "$MD_FILE"
            echo "$NEW_MD_HASH" > "$MD_HASH_FILE"
            HAS_UPDATE="true"
          else
            echo "README.md 无更新"
            rm -f temp_md.md
          fi

          echo "has_update=$HAS_UPDATE" >> $GITHUB_OUTPUT
          echo "merge_status=${MERGE_SUCCESS:-"none"}" >> $GITHUB_OUTPUT

      # ==================== 读取README.md版本号 ====================
      - name: 读取README.md版本号
        id: read-version
        run: |
          set -euo pipefail
          
          # 从本地 README.md 读取版本号
          if [ -f "README.md" ]; then
            # 尝试多种常见的版本号格式
            VERSION=$(grep -E "v[0-9]+\.[0-9]+\.[0-9]+" README.md | head -1 | grep -oE "v[0-9]+\.[0-9]+\.[0-9]+" || echo "")
            
            # 如果没找到，尝试其他格式
            if [ -z "$VERSION" ]; then
              VERSION=$(grep -E "[0-9]+\.[0-9]+\.[0-9]+" README.md | head -1 | grep -oE "[0-9]+\.[0-9]+\.[0-9]+" || echo "")
            fi
            
            # 如果还没找到，尝试从标题中提取
            if [ -z "$VERSION" ]; then
              VERSION=$(grep -E "^#+.*v[0-9]" README.md | head -1 | grep -oE "v[0-9]+\.[0-9]+\.[0-9]+" || echo "")
            fi
          fi
          
          # 如果本地没找到或文件不存在，从上游读取
          if [ -z "$VERSION" ]; then
            echo "本地未找到版本号，从上游读取..."
            UPSTREAM_MD_URL="https://raw.githubusercontent.com/byJoey/cfnew/main/README.md"
            curl -fsSL "$UPSTREAM_MD_URL" | grep -E "v[0-9]+\.[0-9]+\.[0-9]+" | head -1 | grep -oE "v[0-9]+\.[0-9]+\.[0-9]+" > upstream_version.txt || echo ""
            VERSION=$(cat upstream_version.txt 2>/dev/null || echo "")
            rm -f upstream_version.txt
          fi
          
          # 如果仍然没找到，使用时间戳作为版本
          if [ -z "$VERSION" ]; then
            VERSION="v$(date -u +"%Y.%m.%d")"
            echo "警告：未找到版本号，使用时间戳作为版本: $VERSION"
          fi
          
          echo "检测到的版本号: $VERSION"
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      # ==================== 以下步骤仅在需要时执行 ====================
      - name: 执行后续构建（仅在必要时）
        if: steps.check-update.outputs.has_update == 'true' || github.event_name == 'workflow_dispatch'
        run: echo "开始执行混淆、提交、发布流程..."

      - name: Set up Node.js
        if: steps.check-update.outputs.has_update == 'true' || github.event_name == 'workflow_dispatch'
        uses: actions/setup-node@v4
        with:
          node-version: 'latest'

      - name: Install dependencies
        if: steps.check-update.outputs.has_update == 'true' || github.event_name == 'workflow_dispatch'
        run: |
          npm install
          sudo apt-get update -qq
          sudo apt-get install -y jq zip

      - name: 创建 明文源吗_temp.js 用于混淆
        if: steps.check-update.outputs.has_update == 'true' || github.event_name == 'workflow_dispatch'
        run: cp 明文源吗 明文源吗_temp.js

      - name: 混淆代码
        if: steps.check-update.outputs.has_update == 'true' || github.event_name == 'workflow_dispatch'
        run: |
          npm run build
          # 验证混淆文件是否创建成功
          ls -la 少年你相信光吗 || (echo "混淆失败 - _worker.js 未创建" && exit 1)

      - name: 压缩为 Pages.zip 并创建明文发布文件
        if: steps.check-update.outputs.has_update == 'true' || github.event_name == 'workflow_dispatch'
        run: |
          cp 明文源吗 mingwenyuanma.js
          cp 少年你相信光吗 _worker.js
          zip Pages.zip _worker.js
          # 验证压缩包是否创建成功
          ls -la Pages.zip || (echo "压缩包创建失败" && exit 1)

      - name: 提交并推送更改
        if: steps.check-update.outputs.has_update == 'true' || github.event_name == 'workflow_dispatch'
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          
          # 检查添加前存在的文件
          echo "=== 目录中的文件 ==="
          ls -la
          
          echo "=== 添加前的 Git 状态 ==="
          git status
          
          # 分步添加文件并验证
          git add 少年你相信光吗 || echo "警告：少年你相信光吗 未找到或已跟踪"
          git add Pages.zip || echo "警告：Pages.zip 未找到或已跟踪"
          git add 明文源吗 明文源吗.js.upstream README.md .明文源吗_hash .md_hash || true
          
          # 如果有冲突报告，也添加
          git add merge_conflict.md || true
          
          # 如果有旧备份文件，也添加（用于冲突时手动处理）
          git add 明文源吗.old || true
          
          echo "=== 添加后的 Git 状态 ==="
          git status
          
          if git diff --cached --quiet; then
            echo "无文件变更，跳过提交"
            exit 0
          fi
          
          VERSION="${{ steps.read-version.outputs.version }}"
          COMMIT_MSG="自动更新：混淆版 + 备份（版本 $VERSION）"
          
          # 如果有冲突，在提交信息中说明
          if [ -f "merge_conflict.md" ]; then
            COMMIT_MSG="$COMMIT_MSG [注意：存在合并冲突，请检查]"
          fi
          
          git commit -m "$COMMIT_MSG"
          
          echo "=== 提交后的 Git 日志 ==="
          git log --oneline -1

      - name: Push changes
        if: steps.check-update.outputs.has_update == 'true' || github.event_name == 'workflow_dispatch'
        uses: ad-m/github-push-action@master
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          branch: main

      # ==================== 创建/覆盖 Release ====================
      - name: Create GitHub Release
        if: steps.check-update.outputs.has_update == 'true' || github.event_name == 'workflow_dispatch'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          VERSION="${{ steps.read-version.outputs.version }}"
          MERGE_STATUS="${{ steps.check-update.outputs.merge_status }}"
          TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          
          echo "=== 创建 GitHub Release ==="
          echo "版本：$VERSION"
          echo "合并状态：$MERGE_STATUS"
          
          # 检查是否已存在该版本的Release
          RELEASE_ID=$(curl -s -H "Authorization: Bearer $GITHUB_TOKEN" \
            "https://api.github.com/repos/${{ github.repository }}/releases/tags/$VERSION" | jq -r '.id // ""')
          
          # 如果存在，删除旧的Release
          if [ -n "$RELEASE_ID" ] && [ "$RELEASE_ID" != "null" ]; then
            echo "删除旧 Release $RELEASE_ID"
            curl -X DELETE -H "Authorization: Bearer $GITHUB_TOKEN" \
              "https://api.github.com/repos/${{ github.repository }}/releases/$RELEASE_ID"
          fi
          
          # 删除旧的标签（如果存在）
          if curl -s -H "Authorization: Bearer $GITHUB_TOKEN" \
            "https://api.github.com/repos/${{ github.repository }}/git/refs/tags/$VERSION" | jq -e .ref >/dev/null 2>&1; then
            curl -X DELETE -H "Authorization: Bearer $GITHUB_TOKEN" \
              "https://api.github.com/repos/${{ github.repository }}/git/refs/tags/$VERSION"
          fi
          
          # 创建Release描述
          RELEASE_BODY=$(cat << EOF
          ## 部署信息
          
          - **源文件**: 少年你相信光吗
          - **明文源文件**: 明文源吗
          - **目标文件**: _worker.js
          - **压缩文件**: Pages.zip
          - **明文发布文件**: mingwenyuanma.js
          - **标签**: $VERSION
          - **部署时间**: $TIMESTAMP
          - **合并状态**: $MERGE_STATUS
          
          ## 文件变更
          
          已从 \`少年你相信光吗\` 生成 \`_worker.js\` 文件，并压缩为 \`Pages.zip\`。
          已从 \`明文源吗\` 复制为 \`mingwenyuanma.js\` 以供发布。
          
          EOF
          )
          
          # 如果有冲突，添加冲突信息
          if [ "$MERGE_STATUS" = "conflict" ]; then
            RELEASE_BODY="$RELEASE_BODY
          
          ## ⚠️ 冲突警告
          
          本次合并存在冲突，请检查仓库中的冲突标记并手动解决。
          冲突报告文件: \`merge_conflict.md\`
          "
          fi
          
          # 创建Release
          PAYLOAD=$(jq -n --arg v "$VERSION" --arg body "$RELEASE_BODY" \
            '{tag_name: $v, name: ("Pages " + $v), body: $body, draft: false, prerelease: false}')
          
          RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer $GITHUB_TOKEN" \
            -H "Content-Type: application/json" \
            --data "$PAYLOAD" \
            "https://api.github.com/repos/${{ github.repository }}/releases")
          
          RELEASE_ID=$(echo "$RESPONSE" | jq -r '.id')
          
          if [ -z "$RELEASE_ID" ] || [ "$RELEASE_ID" = "null" ]; then
            echo "创建 Release 失败"
            echo "$RESPONSE"
            exit 1
          fi
          
          echo "Release 创建成功：$VERSION (ID: $RELEASE_ID)"
          
          # 上传文件
          for asset in Pages.zip mingwenyuanma.js; do
            if [ -f "$asset" ]; then
              echo "正在上传 $asset ..."
              curl -s -X POST \
                -H "Authorization: Bearer $GITHUB_TOKEN" \
                -H "Content-Type: $(file -b --mime-type $asset)" \
                --data-binary "@$asset" \
                "https://uploads.github.com/repos/${{ github.repository }}/releases/$RELEASE_ID/assets?name=$asset"
            fi
          done
          
          echo "Release $VERSION 及所有资产上传完成"
          echo "=== GitHub Release 创建完成 ==="
